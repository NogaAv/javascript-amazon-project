Lesson 14 - Modules:
--------------
Modules = a better way to organize our code.

Currently, in the amazon.html end of body tag we put:
    <script src="./scripts/cart.js"></script>
    <script src="./data/products.js"></script>
    <script src="./scripts/amazon.js"></script>

The problem - This can cause NAMING CONFLICTS. 
for example- in cart.js we created variable
    const cart = [];

That means we cannot redeclair variable with that same name in any other of the js files, 
It will results in error on the webpage console: 
    "Uncaufght SyntaxError: Identifier 'cart' has already been declaired"

The big problem with <script></script> tags: It's hard to track naming of variables given in all 
js files and it's easy making naming conflicts.

How to solve that problem? => Using js feature names: Modules

Module = contains a variable inside a js file, so that this variable will not cause conflict with 
anything outside the file.
How to create module?
----------------------
As explained, the tag:      <script src="./scripts/cart.js"></script>
- run all the code inside 'cart.js'
- create a cart variable
- cause a naming conflict

first we remove the script tag:
    <!-- <script src="./scripts/cart.js"></script> -->

Create a Module:
================
1) Create a file 
2) Don't load the file with a script tag <script>

By doing so - 
Any variable we create inside the file, will be contained inside the file.
and it won't cause naming conflict.

So we already have the cart.js file with the definition 'const cart = [];'  in it.

Now we learn:
How To: Get a Variable Out Of a File:
-------------------------------------
1. Add type="module" attribute
2. Export
3.Import


1 - Adding type="module" attribute:
Inside the amazon.html file, we go to the last script tag and add: type="module" attribute:
    <script type="module" src="./scripts/amazon.js"></script>

type="module" attribute:
 Let's this file get variables out of other files. Enables this feature.

2 - Export:
Now, we go to the cart.js file, We want to access the variable 'const cart', 
so we add in front of the variable 'export':
    export const cart = [];    //Now this variable can be accessed outside cart.js

3 - Import:
We go to the place where we use that variable, in this case the cart variable is used 
inside amazon.js, and at the top of that file we tell the computer what variable we want to
get from another file:
    import { cart } from '../data/cart.js';     //Note: the .js extention is a must 

* Note:
1. Put all imports at the top of the file.
2. In order for modules to work: we need to use 'Live Server' to open our html files.


Benifits of Modules:
---------------------
1. Helps us avoid naming conflicts. After that change I will get naming conflict only if 
inside tha amazon.js I re-declair the 'const cart' again, but now I have much more control, 
and also: I can still declair the same variable name imported by Renaming the import:

    import {cart as myCart} from '../data/cart.js';    //renaming the import

    const cart = [];  /Now there is no conflict
2. We don't need to worry about the order of files.
with several script tags we needed the order of the script tags to be correct and it's hard to 
manage with big projects.

!Note: We still need a single <script></script> of js file because we still need to load our code.
So the file amazon.js will load the code and will import from all other files.
This file is called: The Entry-point:
        <script type="module" src="./scripts/amazon.js"></script>


 ** Another way to import: Import all the file content and rename, them I can access any func or variable:
  
  import * as cartModule from '../data/cart.js';
  cartModule.addToCart('id');
  cartModule.cart;

--------------------
12:54:44
Create the Checkout Page.

we created folder: utilsunder scripts folder

13:32 - make delete btn in the Checkout page responsive/interactive

In the checkout page: When we click the delete button:
1. The products are removed from the cart (we created removeFromCart() function in cart.js)
2. We need to update the HTML of the checkout page 


How can we remove items from the page? One way to do this:
----------------------------------------------------------
1. Use the DOM to get element to remove 
2. Use .remove() method: Every element we get from the DOM has a method: .removed() .Example:
    const button = document.querySelector('button');
    button.remove();   <==

BUT, How can we know what element on the DOM to call .remove() on?
We will add new class to the out-most div of the product element in the checkout page:
(It's the div with the class:  class="cart-item-container"), we added the 
    class="js-cart-item-container-${matchingProduct.id}" 
i.e- we concatenated the product id to the class name. Now, deleting this item by class is simple:

In the event-listener function:
    document.querySelector(`.js-cart-item-container-${productId}`).remove();


We want the state of the cart to be saved when refreshing the page and when navigating to 
different pages of the app. Therefore we =
Add the cart object to our: LocalStorage:
We added function to save cart to the localStorage in the cart.js.

**Whenever we upfdate the cart, we need to save it to localStorage, so it doesn't reset when we 
refresh the page.
===========================================================================================

Lesson 15- 
External Liberaries, MVC, Finish the Checkout Page
--------------------------------------------------
External Libraries = code that is outside of our project.

Why we use external libraries?
- let us share code
- save time
- avoid duplicating work 

How to use external libs in our code?
========================================
1) Onw way is adding the link to the lib code with <script> tag:
Example:
    - we added a script tag to the checkout.html with src="" that points to url of js file with 
    function hello() implemented:
        <script src="https://unpkg.com/supersimpledev@1.0.1/hello.js"></script>
        <script type="module" src="scripts/checkout.js"></script>
    - we called hello() from the checkout.js file 
    - now when navigating to the checkout page on the website, the console runs the function and we see 'hello' in console.


Less preferred option to load external libs: with <script> tag (since it may result in 
naming conflict)-
* we load external libs using the <script> tag.
* We add the script tag before any other script tag so that the functions in the lib will be 
available to out code.


2) Best practice for loading external libs - using Modules:
How do we use external libs and Modules togather? = 
-------------------------------------------------
We will use special version of the liberary, called:  'ESM Version'.

ESM Version = 
ESM = EcmaScript Module (EcmaScript = Javascript)
It is a version that works with Javascript Modules.

The same 'hello()' function but this time link to the ESM version: 
    https://unpkg.com/supersimpledev@1.0.1/hello.esm.js 
It's actually the same implementation but with the 'export' keyword infront of the function.
This 'export' turns the function to ESM version.
How to use this ESM version in our code? 
Instead of script tag -> At the top of the js file where we want to call the function, we just 
add the import of the module and the path is a URL:
    import { hello } from 'https://unpkg.com/supersimpledev@1.0.1/hello.esm.js';
next, just call 'hello()' in code.

**Keep in mind: Not every lib has ESM version, so for some libs we still need to use <script> tag

How do you put code on the Internet? any HTML, js, css files?
--------------------------------------------------------------
Watch video: 'How to put an HTML website online (on the Internet), on: 
    https://www.youtube.com/watch?v=p1QU3kLFPdg



===================================================================
Using external lib: 'Dayjs'
---------------------------
The following link includes the compressed code of the DayJS lib to be added in <script> tag.
Compressed code makes the code load faster to our code
MINIFICATION = The process of compressing the code (minify the code)
https://unpkg.com/dayjs@1.11.10/dayjs.min.js

This version of the code we can add to script tag.
But to add as Module:
We will instead write the folloing import at the top of the checkout.js:
    import dayjs from 'https://unpkg.com/dayjs@1.11.10/esm/index.js';
and call dayjs() in our code.
NOTE: We did not write 'import {dayjs} ...' with {}, why?

This is called:
DEFAULT EXPORT (vs NAMING EXPORT which is the regular export and import using {})= 
----------------------------------------------------------------------------------
- another way of exporting 
- we can use it when we only want to export 1 thing from a file.

Some peaple like using default exports because they feel that exporting only 1 thing from a file 
makes the code cleaner. However in my code it is my choice to use whatever I want.


Handeling the 'choose a delivary option' in the checkout page:
- The cheapset option - FREE shipping takes: 7 days to deliver
- 4.99$: takes 3 days to deliver 
- 9.99$: takes 1 day to deliver 

so How to get these dates:
1. Get today's date 
2. Do calculation (add 7 days, 3 days...)
3. display the date in easy-to-read format 
We will use popular liberary for this, called: 'DayJS'

===========================
14:20:30
'Normalizing the data' = we save the delivery-option seperately from the cart, in order to 
avoid duplicating the data-
We added under 'data' folder: 'deliveryOptions.js' file

* Removing manually data from local-storage:
If I want to remove data from local-storage of the webpage:
In the inspect->console:  
to remove specific data, like the cart(I want to test the default values in cart when it's empty):
    localStorage.removeItem('cart');
and if I want to remove ALL the data in the loval storage:
    localStorage.clear();

14:43:30

MVC - Design Pattern that lets us orgenize our code:
===================================================
Inside checkout.js:
We put all the code that generates the web page into function: renderOrderSummary(),
and whenever the delivery-options updated, this function calls itself (recursion). Why?

This delivery option will make changes to several elements in the page:
i.e- to the Delivery date title, and to the Order Summary where the cost is updated.
This is why we better re-run the whole function that renders the page as whole:
      renderOrderSummary(); //RECURSION

Instead of using the DOM and change the elements directly, we re-run the code to
build the page again whenever it is updated.
renderOrderSummary();

This technique where we:
1. Update the data 
2. Regenerates all the HTML 
is called = MVC = Model-View-Controller

In MVC, We split our code into 3 parts:
1. Model = All the code that saves and manages the data (in our project its: 'cart.js')
2. View = This is code that Takes the data and displays it on the page (in 'checkout.js'-> renderOrderSummary()) 
3. Controller = runs some code when we interact with the page (The event-listeners)

These 3 parts interact with eachother in a loop: 

Model ---> View ---> Controller --
 |_______________________________|

first, we use Model to generate the view (we took the model/data which is our cart, and 
in chckout.js we generated the View) 
Then, when we interact with the view, it runs the Controller 
Then, the Controller will update the Model (The EventListeners render the webpage)
And finally, we use the updated Model to generate the view (renderOrderSummary())

We use MVC because = This way it makes sure the page always matches the data


Lesson 16 - TESTING:
======================
1. Manual Testing = When we manualy open our website and try our code. 
Disadvantages: 
- Hard to test every situation 
- Hard to re-test the code 

Best practice:
2. Automated Testing = Using code to test code 

We created upper-level folder: 'tests'. It will containg js files corresponding to each 
code we want to test.

REMEMBER: 
We can't run javascript files directly. We need to load js files from html file.
so we create html file for the js test files to be loaded there to the web (run the tests.html 
with Live-server).

Inside tests/tests.html we added the script tag to load the js test file.
Note: we need to add type="module" because we want to use the ESM feature:
    <script type="module" src="monyTest.js"></script>

How many test cases should we have?
1. Basic test cases = tests if the code is working 
2. Edge cases = test with values that are tricky 

Inside the tsets.js:
Naming conventions for the tests titles: To describe what the code is doing.
We should group related tests:
'test suite' = group of related tests

15:58:40-
Testing Framework:
================== 
It's external library that helps us write tests easier. 
We will use a popular testing framework called: 'Jasmine' 

Jasmine 
--------
Link for download: https://github.com/jasmine/jasmine/releases/tag/v5.1.1 
Docs: https://jasmine.github.io/api/5.1/global 

we downloaded the zip file: 'jasmine-standalone-5.1.1', extracted the folder and added it to our project. We renamed the folder to: 'tests-jasmine' in order 
to make it clear this folder contains tests created by jasmine.

So- this is another way to load external library to our project- By downloading 
the code and putting it in our project. It's usefull when external lib has 
many different files, like this lib.

Inside jasmine folder:
'SpecRunner.html' - is the file that loads all the tests (so it does the same thing as our 
tests/tests.html we created before).
in jasmine: 'spec'='test'
We renamed this file to tests.html and when we open this file with Live-server, we see 
a nice website that presents the testings.
so jasmin:
- create test suite 
- create tests (spec filder is the test folder) 
- compare values and display result 

From tests.html we delete the default example scripts tags:
  <!-- include source files here... -->
  <script src="src/Player.js"></script>
  <script src="src/Song.js"></script>

  <!-- include spec files here... -->
  <script src="spec/SpecHelper.js"></script>
  <script src="spec/PlayerSpec.js"></script>

we also delete the src folder and the spec folder(contains example code).
So, aventually we have inside test-jasmin folder: 
the lib folder, tests.html (and license file).

Under the main 'test-jasmine' folder we create our files for testing and we should keep 
the folder structure similar to the project tested, so for example:
The mony.js file is located under Utils folder. so- in our jasmine folder we create monyTest.js 
under Util folder as well. to match the structure of folders and files.

Instructor's mistake:
** Instructure note:  In our project- There is mistake in the structure of the project:
The data folder (that contains js files) should be under the 'script' folder and not outside it.
For this reason now the jasmin folder inner structure doesn't match exactly the project structure, but it should (i.e- the data and Util folders should be at the same level in the project, just as it is in the testing jasmin folder). So the structure in jasmin we made is the correct one.

'Flaky Test' = test that sometimes passes and sometimes fails.

'Mocks' = a feature of jasmine, lets us replace a method with a fake version.
spyOn() - function in jasmine that lets us create Mock 
    !!NOTE: A mock only latst for 1 test (so for every test I need to use spyOn() if I want to mock)
spyOn() has special feature - It records every time a method is used, and so we can after check parameters:

//toHaveBeenCalledTimes() - checks how many time localStorage.setItem() was called in the code above. 
//Note: This only works if the method was mocked by spyOn()
    expect(localStorage.setItem).toHaveBeenCalledTimes(1);

Also- we can check the values that the mocked calles returned (on docs)

**After we run the testing jasmine and see on jasmine webpage that all tests pass, we CLEAN the localstorage on 
the webpage - 
We will remove everything from localStorage, because we want to make sure we start clean.
NOTE: The jasmine webpage has the same localStorage of our project!-localStorage belongs to a DOMAIN, 
in our case the domain is: http://127.0.0.1:5501 
and since both our project and jasmin run by the LiveServer - they have the same localStorage, so after the testing 
we better clear the storage to not mess anything up:
    On the jasmine webpage we right-click->Inspect->Console->  and run the command: 
        localStorage.clear()


16:51:30-
Up until now we made:
'Unit Tests' = testing 1 piece of the code.

But what if we want to test a whole page, or part of the page? This is more complicated test, 
called:
'Integration Test' = tests many units/pieces of code working together.

like: renderOrderSummary() function inside orderSummary.js file. This function runs many other functions and pieces of code.

renderOrderSummary() creates part of the checkout page. 
When we test a page or part of page, we have 2 things to test:
1. How the page looks
2. How the page behaves

How do we test how the page looks?
-----------------------------------
the page html order summary section is created and loaded in orderSummary.js, with line:

      document.querySelector('.js-order-summary').innerHTML = cartSummaryHTML;
so- inside the 'tests.html' file, we will add <div><div> inside body, and this div 
will serve as a container, imitating the div with the class="js-order-summary" in the project's 
code. 
we use container inside the <body> and not insert to the body itself because it may contain 
the results of jasmine to be displayed in the jasmine webpage.

so we added :
        <div class="js-test-container"></div>
and now we can query and use that container in our testing code.


17:27:10-

HOOKS:
======
Hook - Lets us run some code for each test.
'beforeEach' hook = It's a setup code we can run before running test.

Hooks in Jasmine:
=================
beforeEach() = runs code before EACH test
afterEach() = runs code after EACH test (gppd gor cleanup code)
beforeAll() = runs code before ALL tests
afterAll() = runs code after ALL tests

Process when we run code:
--------------------------
1. Make changes to code 
2. Re-run the tests 
3. Save changes to Git

we renamed 'tests-jasmine' to 'tests'


Lesson 17 - 
OOP = Object Oriented Programming:
===================================
Organizing our code into objects. 

So far- we used in our code- 
Procedural Programming = a set of step-by-step instructions(=functions) - (in cart.js- cart object declaired up in file and the rest of file has seperated functions for the cart)

we created OOP version to the cart.js => 'cart-oop.js'
According to OOP = We grouped our data and functions togather into an object.
* Now, How we test this code? 
At the top of 'checkout.js' we added:
    import '../data/cart-oop.js'; 
This is another syntax to import code. This will run all the code in that file without importing anything, which is what we want for testing it. Now we open 'checkout.html' which runs 'checkout.js' and we open the console to see what we consoled in the cart-oop.js file.


Why do we use OOP?
* OOP - tries to represent the real world. Makes the code intuitive and easy to understand 
* Easy to create multiple objects. 
For example: 
The real Amazon.com has a feature called: 'Amazon Business' where you can have seperate cart for your business.

So- How do we create 2 separate carts in our current code?
With OOP - this is easy: 
1) we can just make a copy of the cart-oop object we created: 
We go to 'cart-oop.js' , copy the cart object code, paste it under the first cart object, 
change the object's name - we changed it to: businessCart, change the name of cart in the localStorage to diffrentiate between carts, and that's it! (in- 'cart-oop-no-class.js')

BUT - This way we're copy-pasting a lot of code. It makes our code messy and hard to manage.
We will resolve that by:
2) Using a function to generate multiple objects:  'cart-oop-function.js'

3) Better way for generating objects:
CLASS:
class = Object generator
Classes are cleaner and has more features than a function.

With classes, each object of a class is called: Instance of a class:
    const cart = new Cart();   //cart is instance of Cart class 

We can also check if an object is an Instance of a class:
    console.log(cart instanceof Cart);  //true

Benifits of classes:
--------------------
- A class looks like the object that it generates, and it is cleaner than using function to 
generate object.
- Classes have extra features for Object-Oriented Programming:
    - Constructor = Lets us put setup code inside the class. 
    * It is a unique function that is called automatically when an object is created.
    * It has to be named "constructor".
    * It should not return anything.

Special features of class:
Private properties and methods:
--------------------------------
Some properties and methods should not be available outside the class. 
for example- this is a problem if outside the class a user does this and changes localStorage:
    cart.localStorageKey = 'aaa'; 
so we add '#' infront of the property name, and make it 'private property' as opposed to 
'public property'.

field = property

methods can also be private. for example: loadFromStorage() should not be called from outside the class. so we add #:
Now - We will Use classes in our project:
we will need to replace every place we use cart in our project with the class cart.
However - The istructor left this as challange exercise for me.


18:29:50-
We will now - Keep working on Home-Page:

inside products.js we have array ob objects, each object represents an object.
We will learn a technique = 
Converting an object into a class:
-----------------------------------
We will use a class to generate these objects.

in products.js-
Technique demonstrated by Instructor:
"Converting an object into a class":
------------------------------------
We sent the class constructor an object as whole, and the class converts it to class.
We actually send an object and wrap that object with a class.
The reason we do this =
Classes has more features then object, like: we can add methods, private properties and methods.

With this technique we get the same object as before, but enhanced version. (It has some extra features)

Now, after converting the regular objects to class-objects, We added to product 
class Methods:  getStarsUrl() and getPrice() 
and then- we went back to 'amazon.js' and 'orderSummary.js' and used there these methods inside 
html ctring construction. This makes the code cleaner.

Lastely - we open test.html with LiveServer to make sure the code still works and that all the 
tests pass


18:52:20 = 
Lesson:  INHERITANCE:
======================
Inheritance - lets us reuse code between classes.

In the Home page, we have different TYPES of products:
                         ----------------
For example- T-shirt and Toaster:
T-shirt is 'clothing' product, and Toaster is 'appliances' product
Both are products: They have name, price and rating, 
But They are a MORE SPECIFIC type of product. 

clothing has the regular properties of product, but it can also have specific properties, like:
a size-chart. So, a class for such product would look like this:

    class Clothing{
        id;
        image;
        name;
        rating;
        priceCents;

        sizeChartLink;    //<- specific for clothing.
    }

BUT, If I add this class as is in addition to the Product class we have, we will be 
duplicating code, since both classes has common properties (the base product properties) = 
These is why we have the OOP feature: Inheritance 
Inheritance = allows class to get properties and methods from another class, so we don't need 
to copy redundant code. 
So instead the class described up here, we will use inheritance:

   class Clothing extends Product{
        //Get all properties of Product

        sizeChartLink;

        constructor(productDetails){
        //Get the constructor of Product

          this.sizeChartLink = productDetails.sizeChartLink;
        }
    }

Inside products.js we added inheriting child class: class Clothing

*We use inheritance when we have:
One class is a MORE SPECIFIC TYPE of another class.
Inheritance = Lets us reuse code between classes.

super(); - calls the contructor of the parent class.

*NOTE: If we don't create a constructor, by default it will run the parent constructor:
so-

class Clothing extends Product{                       class Clothing extends Product{
                                --By Default is:-->     constructor(param1){
}                                                          super(param1);
                                                           }
                                                      }


So now, we have Product class and Clothing class. 
How do we know what product in the products array we should convert to Product class and which 
to convert to Clothing class?
---------------------------- 
Discriminator Property = property that tells us to which class we should convert it to.

In our products array, some have the property:
    type: 'clothing',
this will serve as the discriminator property.
now, in the .map() we check if this property exists in the current object and accordingly 
call the Clothing() constructor.

Next - we Display the size chart link on the page:
On home page, wherevert there is a clothing product - we will display size-chart 
undernith.
We do that using inheritance => we added to the child Clothing class a method: 
extraInfoHTML() 
And since we call that method to EVERY object in the products array when we create 
the amazon home-page, we also need to add that method in the parent class, only there 
it returns '' empty string:
In amazon.js:

// for product of type Product it returns '', for product of type Clothing it 
// returns link
    ${product.extraInfoHTML()}
    <div class="product-spacer"></div>

NOTE - Don't get confused:
The following iterating code inside 'amazon.js':
    products.forEach((product, index) => {..} 
Iterates through the objects in a way that 'product' may be a reference to Clothing 
object or a reference to Product object. SO- when calling the method:
    product.extraInfoHTML()
The correct method is induced according to the type of object. 

This is called:
 POLYMORPHISM = use a method without knowing the class.

OVERRIDING:
--------------
extraInfoHTML() - In child class it Overrides the parent method.
Method Overriding: method override/replace the parent's method 

If we really want to access the parent class from the child class, we use super 
inside the child object:
    super.extraInfoHTML()

**Testing classes = Is the same as normal tests.

Built-in Classes:
----------------
new Date() = generates an object that represents the current date.

We used earlier - DayJS library:
DayJS uses this Date class behind the scenes.
DayJS gives us a lot of extra features.
- so we use DayJS instead of Date directly.

'this' keywoed in JavaScript:
-----------------------------
* As we said - "this" lets an object access its own properties.
In JS - "this" can actually be used ANYWHERE in our code, but if it's outside an object, we get:
'undefined'
Originally in javascript, "this"=window object
However, this behaviour caused alot of confusion, therefore:
when they released Javascript modules, inside a module, "this"=undefined.

* We cannot use 'this' inside regular object like this:

    const object2 = {
    a: 2,
    b: this.a, //invalid code - 'this' is not yet defined here
    };

* Use "this" inside function:
    function logThis() {
      console.log(this);
    }
    logThis(); //undefined
again, we are NOT inside an object, so there's nothing for "this" to point to.
BUT - "this" has special feature - and inside a function we can change "this" to whatever we want

logThis.call() //logThis.call() runs the function just the same as logThis(), only we can 
set the value of "this" to whatever we want. So-

logThis.call('hello'); //hello

So- logThis.call() enables passing to function value for "this" as first parameter.

   function logThis(param1, param2) {
      console.log(this);
    }

  logThis("hello"); //undefined
  logThis.call("hello", "world"); //hello

* Arrow functions do NOT change the value of "this"
"this" inside an arrow-function- keeps the value that it has outside the arrow-function.

WHY are Arrow functions designed this way?  (-i.e- to keep 'this' with the value it has outside the arrow-function?):
--------------------
JS had a common problem in the past:
see code:

const object3 = {
    method(){
        console.log(this); //When we are inside the method, 'this' points to the object

        [1, 2, 3].foreach(function() {
         console.log(this); //But here, inside the callback, it points to undefined
        })    
    }
};

When we are inside the method, 'this' points to the object. 
But when we are trying to do the foreach loop, there, the 'this' doesn't point to the object anymore, it points to undefined, because this 'this' is inside regular function, which 
has no access to the 'this' of the object.
Remember - In a regular function - 'this' is undefined.
SO - To solve this, We have the Arrow-function.
With Arrow function, the 'this' is equale to whatever it's value before the arrow function call.
Arrow functions do not change the value of "this". 

const object3 = {
    method(){
        console.log(this); //When we are inside the method, 'this' points to the object

        [1, 2, 3].foreach(function => {
         console.log(this); //Here, inside the arrow-function, 'this' still points to object
        })    
    }
};

so- Arrow functions were designed to avoid accidently overriding "this".

To summarize the "this":
1. Inside a method, "this" points to the outer object.
2. Inside a function, this=undefined, But we can change that with functionName()call(param);
3. Arrow functions do not change the value of "this". 


Lesson-18:  
Backend
==========
Backend - is another computer that manages the data of a website
On the other hand, the webpage/user-computer called Frontend - where we can see and interact with 
the products.

How does our computer/frontend send information to the backend?
When 2 computers are connected to the internet they can send messages to each other using 
a feature called:
HTTP = HyperText Transfer Protocol
and inside http message we can attach information, like our Amazon Order.

Let's send our first HTTP message using javascript - We created onside data folder file 
for tractice - data/backend-practice.js:
To send an HTTP message, we will use a built-in class (provided by javascript), called : 
    XMLHttpRequest

Common types of request we can give to the backend:
    GET = get some information from the backend.
    POST 
    PUT 
    DELETE 

Using HTTP, we can send a message to any computer connected to the Internet. Now, to locate 
another computer on the internet, we need to use URL.

URL = Uniform Resource Locator 
------------------------------ 
- Like an address, but for the Internet.
- Helps us locate another computer on the Internet.

URL looks like this:
https://amazon.com 
https://youtube.com 
https://supersimple.dev 

- https - a secure version of the http protocol 
- after the '://' comes the Domain-name : amazon.com, youtube.com, supersimple.dev 

so, amazon.com points to one of Amazon's backend computers.
youtube.com points to one of YouTube's backend computers.
supersimple.dev points to the instructor's backend computer. 

This tutorial's backend computer for practice, located on:
    https://supersimplebackend.dev 
Documentations on:
    https://supersimplebackend.dev/documentation 

after sending the message - we open in checout webpage a new Tab:
 'inspect' -> 'Network'

and in the opened network tab, down, we see table (Name, Status, Type...), 
This table shows us:
All the HTTP messages that are coming in and out of our computer.

!! Important to note about the Network tab:
In the Network tab, messages only appear in the table AFTER we open the console. 
If we send some messages and only then open the console, it will not show up in the tab. 
So, to make sure our messages we send are recorded in the network tab, first we will open 
the network tab and refresh the page to re-send those messages.
19:42:42 

up in the network tab we can search for message by typing inside the "filter" input :
part of the url we sent message to. 
like: 'supersimplebackend', and click the supersimplebackend.dev message found.
after click we get more details on the message - several tabs appear = 
'Headers' tab- gives us detail about our message/request we sent.
'Response' tab- Is the response I recieved from the backend. 
'Preview' tab- It presents the response in an easy to read format

Some terminology:
"Request" - When we sent message to the backend this message is called request.
"Response" - Http message the server sends to us after the request sent 

"Request Response Cycle" - Each request we send will get one response from the server.
It's always 1 request, 1 response.

URL Paths:
-----------
We can send different requests to the backend using URL paths.
URL path - The part in the URL that comes after the domain name. foe example - 
In this URL, the url-path is '/hello':
    https://supersimplebackend.dev/hello

In this URL, the url-path is '/products/first':
    https://supersimplebackend.dev/products/first

In this URL, when there is no url-path, the url-path is '/':
    https://supersimplebackend.dev

* Each URL path will give us a different response. 
* A backend only supports a certain set of URL paths.
If we send a request to a URL path that is not spported, the backend will respond with an error.

Status Code:
-----------
Whenever we get a response from the backend, the backend sends us a Status Code which tells us 
if we succedded or failed. 
- Status code that starts with 4 or 5 (400, 404, 500) = means the response Failed.
starting with 4 means it's Our problem (sender's problem)
starting with 5 means it's the Backend's problem (backend crushed) 
- Status code that starts with 2 (200, 201, 204) = Succeeded 
We can also see the status-code in the network tab 

How do we know which URL paths are supported, and which are not?
----------------------------------------------------------------- 
There is actually no way to figure out all the URL paths that are supported and this is for a 
security reason.
However, Some backends provide a documentation page that lists the URL supported and also the 
response that they give.

For this tutorial's backend, the documentation is on: 
    https://supersimplebackend.dev/documentation

Backend API:
-------------
The list of all the URL paths supported, is called: The Backend API
API = application programming interface 
Interface = How we interact with something 


*The backend can response with different types of data.
---------------------------------------------------------
- For example:
    'https://supersimplebackend.dev/hello' returns response with type of text.
we can go to the 'network' tab and after clicking the 'hello' repsonse -> under 'Headers': 
we can see it's text:  
    content-type: text/plain; charset=utf-8
- another example:
    'https://supersimplebackend.dev/products/first returns us json type. 
In the network tab I can see:  
    content-type:application/json; charset=utf-8 
When receiving json response we can use JSON.parse() to convert the response into js object. 

JSON.parse() - This allows us to send Javascript object across the Internet, to the backend. 

- another data type the server can send as response is: HTML:
    'https://supersimplebackend.dev/documentation'
returns response type of html:
    content-type:text/html; charset=UTF-8
and in console we see the html page 

- another type of data the backend can respond to is: Image 
    'https://supersimplebackend.dev/images/apple.jpg'
  returns an image. In console we see the the image displayed as text (raw data) so we see random 
  characters.
  and in network tab we see the data type:
    content-type:image/jpeg 


Using the browser = same as making a GET request:
=================================================
* How can we see that image response as an image and not that raw data - random characters 
in the console?
- When we type a URL in the browser, it actually sends a GET request.
so typing in the browser url, is actually the same thing as writing in our code get request.
The difference is that when typing in the browser the url, The response is displayed in the webpage in a more usefull way: 
If the response is image we see the image and not the raw data, also if 
the respone is html page then we see the html displayed as webpage and not as plain raw text of tagd.

so typing in the browser url:  https://supersimplebackend.dev/images/apple.jpg 
will display actual image on an apple 

and if I type in the browser url: 
    https://supersimplebackend.dev 
then the webpage display the response from the server as text:

    Hello! This is SuperSimpleDev's backend.

    Documentation page:
    https://supersimplebackend.dev/documentation 

and if I type https://supersimplebackend.dev/documentation 
then I see the documentation as webpage. and not raw html

So- 
** Using the browser = same as making a GET request

Testing with backend:
---------------------- 
We wait untill the backend finishes to load (by using jasmin 'beforeAll()' hook to perforjm that operation once and prior to ant test that run) and then we use the done() function we passed 
as parameter to the beforeAll((done) => {}).

We added beforeAll() hook that calls the loadProducts() function, and also passed the done 
callback as parameter so that the tests wait untill the done is called and when all products loaded.

By the way, we can also use done in:
beforeEach(done => {}) and in it(done => {}) as well, to wait for backend code to finish:

    beforeEach((done) => {
        ...
    });

    it((done) => {
        ...
    });

20:30:56 - 

PROMISES:
============
- better way to handle asynchronous code 
- similar to jasmine's done() function- let us wait for some code to finish, before going to 
  the next step.

In checkout.js we practice using promises.

Creating a Promise:
These are built-in class.
When we create Promise object we must give it a function as argument(arrow-function). and-
It's going to run this function IMMEDIATELY.
    new Promise((resolve) => {
    console.log('promise'); //immediately logs 'promise' to webpage.
    });

1'st param of the passed function is 'resolve'. 'resolve' is a function.
- similar to done() function 
- lets us control when to go to the next step.

..and what is the next step? 

The 'new Promise()' call is made by the js thread, BUT the function we pass it as argument and 
which runs immediately, actually runs by other outer thread (threads of libuv and event-loop seperated from the v8 js engine) and runs AT THE SAME TIME the rest lines of code in our app runs.


(My note: resolve is a callback function passed to the event-loop to be pushed back to app stack after 
the async code finished and resturns, so that the resolve callback gets executes by javascript 
thread of our app)

Promises gives the ability to run 2 groups of code at the same time.
The reason Promises designed like this:
- It allows Javascript to do multiple things at the same time. So when the Promise finishes, 
it can do a next-step. BUT this next step is seperate from the rest of the code, 
and we going to have to add that next step.

To add a NEXT STEP to a promise, we will use a method called: .then() 
and that methods gets a method as argument.

so-
1. first we run the asynchronouse code (the callback function passed to Promise),
2. then we wait for it to finish and run resolve() 
3. resolve() makes it go to the next step in the .then() method

*I will use Promise for async code if I want to do something after the async code finishes and as NEXT STEP (like- handeling return value, or handeling data changed by this async func etc..) 
If I don't need a next step, then no need for Promise/Async-await/callback to handle a next step, like for example: writing to log-file asynchronously, I don't need next step after that..

To understand the order of execution, we wrote the code:
--------------------------------------------------------

        new Promise((resolve) => {
            console.log('start promise'); 

            loadProducts(() => {
                console.log('finished loading');
                resolve(); 
            });
        }).then(() => {
            console.log('next step');
        });

and see on console the log order:

    start promise
    load products
    finished loading
    next step

So- resolve() lets us control When to go to the next step.

The Promise version of loadProduct:

            new Promise((resolve) => {
            loadProducts(() => {
                resolve();
        });
        }).then(() => {
            renderOrderSummary();
            renderPaymentSummary();
        });

As we can see- The Promise code we wrote make the same as the loadProducts callback version:

        loadProducts(() => {
            renderOrderSummary();
            renderPaymentSummary();
        });

SO-
Why do we use Promises?
------------------------ 
why not use the callback version? It seemd less code to write.. The answer:
Callbacks have big problem => Multiple callbacks cause a lot of nesting (Nesting Hell)

We added layer of nesting. 
The problem: If we have lots of callbacks, our code will become more and more nested, and 
less and less readable:

        loadProducts(() => {
            loadCart(() => {
                loadOrders(() => {
                    loadHistory(() => {
                        renderOrderSummary(); 
                        renderPaymentSummary();
                    });
                });
            
            });
        });

So, Promises let us solve this problem by FLATTEN our code.

The code with Promises instead of nested callback, looks like this:
[code #1]:

        new Promise((resolve) => {
            loadProducts(() => {
                resolve(); //go to next step (i.e- 'then()')
        });
        }).then(() => {
            return new Promise((resolve) => {
                    loadCart(() => {
                    resolve(); //go to next step (to next '.then()' if exist)
                });
        }).then(() => {
            renderOrderSummary();
            renderPaymentSummary();
           });
        });


Compare Promises and Callbacks:
Although Promises requires setup code, it keeps our code relatively flat and the code 
doesn't become more and more nested like in callbacks.
Promises helps us keep our code flat , and let us avoid nestings.

This is why- it is recommended to: Use promises instead of callbacks!

Features Promises have:
-----------------------
1. resolve(param) -> the parameter is sent as argument value to the next .then(), and this way we can share values between two steps of a promise.
2. We can run multiple promises at the same time.
Currently (see in [code #1] above) we wait for things to load one at a time:
we wait for the products to load, and then we wait for the cart to load, and then we go to the next step and render the page.

To make it more efficient, we can load the products and the cart togather at the same time.
To do that we can use:  Promise.all()

Promise.all()
=============
- lets us run multiple promises at the same time 
- and wait for ALL of them to finish


FETCH:
======
fetch() = better way to make HTTP requests 

currently in products.js we use in loadProducts(): XMLHttpRequest, to send 
request to the backend, and it uses callback 
      const xhr = new XMLHttpRequest();

fetch() also let us make a request to the backend, but fetch() uses Promise!

fetch() makes http request. By default makes GET request, so we passed the url here:

    function loadProductsFetch() {
    
        fetch('https://supersimplebackend.dev/products').then((response) => {
            console.log(response); //we see the response with details (status, url, body etc..)
            return response.json();  //we return, because it is a promise and we need to wait 
        });
    }

instead of using callback to get back the response, fetch() uses Promise, 
so we can call on the returned promise the .then() and the parameter inside 
is the value of response object returned from server.

console.log(response); //we see the response with details (status, url, body etc..)
How to get the data attached to this response object? 
By calling '.json()' on the response:
    response.json();

response.json() is asynchronous, it returns a Promise. so we need to wait for this promise to finish before we continue to the next step. to do that: inside .then() we can return another promise. and so when we return a promise, it waits the promise to finish before it continues to the next step.  ..see more in code

Last lesson-

21:13
Async await:
===========
= even better way to handle asynchronous code
so far we used Promises, but the problem with promises - it creates alot of extra code.

Async await is a shortcut for promises.

async = makes a function return a promise! 
so, this following function:

    async function loadPage(){
        console.log('load page');
    }

is same as this:

function loadPage(){
    return new Promise((resolve) => {
        console.log('load page');
        resolve();
    })
}

21:15:30

this following function:

    async function loadPage(){
        console.log('load page');
        return 'value2';
    }

is same as this:

function loadPage(){
    return new Promise((resolve) => {
        console.log('load page');
        resolve('value2');
    })
}

so- async=makes a function return a promise.
What's the point of this feature?
= async lets us use the second feature: await.

await = 
--------
- lets us WAIT for a promise to finish, before going to the next line.
- lets us write asynchronous code like normal code (line by line).

so this code:
    async function loadPage() {
        console.log('load page');

        await loadProductsFetch(); 

        return 'value2'; 
    }
is shortcut for this code:

    function loadPage() {
        return new Promise((resolve) => {
            console.log('load page');
            resolve();
        }).then(() => {
            return loadProductsFetch();
        }).then(() => {
            return new Promise((resolve) => {
                resolve('value2');
            });
        });
    }

 !Important to note:
 We can only use await, when we're inside an async function. (it's actually the main reason we use async - in order 
 to use await which ,which our code look so much clearer).

async await can only be used with promises. It doesn't do anything with a callback.

21:22:34
More details about async await:
-------------------------------
- we can only use await inside an async function.
Also, The CLOSEST FUNCTION has to be async.
For example: We cannot use 'await' on the innerFunction() unless this function is also async

    async function outerFunction(){
        console.log('hello');

        function innerFunction(){
            await loadProductsFetch();  //x invalid code. This function must be async
        }
    }

- If we use await with Promise that calls resolve(value) with a value as argument, 
then the value is not sent to '.then(value)' as we've seen before when not using await, instead, 
with await- this value is returned from the await so we can catch the value by assignning to 
variable ('const value' here):

    async function loadPage() {

        await loadProductsFetch(); 

        //instead of .then(), with await we return the value here, like normal code
        const value = await new Promise((resolve) => {
            loadCart(() => {
            resolve('value1');
            });
    });

    console.log(value); //'value1'

    renderOrderSummary();
    renderPaymentSummary();
    }
    //.then((value) => {...})  <- instead of this, we get value by 'const value'

- We can use await with Promise.all() as well (instructor left it as exercise) 

ASYNC AWAIT:
= shortcut for promises 
= lets us write asynchronous code like normal code 
Therefor, Best Practice: 
When working with asynchronous code: Use async await, over promises and callbacks


Error Handling 
===============
When sending HTTP requests, we could get unexpected errors. (for example: No internet connection, bad url etc..)

How do we add Error handling to calbacks?
-----------------------------------------
In data/products.js, we go to : loadProducts() function (which uses callback, not promise),
This function uses callback to send a request and get a response.
What if there's an error along the way?
* For callbacks we set up a seperate callback just for errors.

How do we add Error handling to Promises?
-----------------------------------------
In data/products.js, we go to : loadProductsFetch() function (which usee promise).
To handle errors in promises, promises give us 2 methods:
.then()
.catch() 
so if the request has an error, it will go to the .catch() method.

How do we add Error handling to 'async await'?
---------------------------------------------- 
In checkout.js - loadPage() function we use async await. 
we will use here new syntax called:  try catch 
Inside the 'try' we put the code that may cause error. 

so catch() workd same as .catch() in regular promise 

More details about try-catch:
-----------------------------
- We don't need to use try/catch only in async-await function. 
We can actually use try/catch with synchronous code (or normal code). For example:

If we try to run function that doesn't exist, it will throw error. 
we can catch it with try-catch :

    try{
        doesNotExist();
        console.log('next line');
    } catch(error) {
        console.log('Error!');
    }

- Whenever we get an error, it will skip the rest of the code. 
so in the above code, the 'next line' statement is not executed.

Why don't use try/catch everywhere in our code?
- it's meant to handle UNEXPECTED ERRORS (code is correct, outside our control) 
so we can give instructions in error message on what to do.

Last thing to know about error handeling - 
We can manually create errors.
To manually create error, we use the keyword: throw 
we throw error that we will catch later. 

for example:
Inside try-catch we added:
    throw 'error1'; 
It manually creats error.it will skip the rest of the code and get to the catch() block.
we can give throw any value, here we gave string of message, and the catch(error) 
the value is inside the 'error' argument 

*If we're using Promises, there are 2 ways to manually create an error.
1. Inside the new Promise we throw error

if we await a promise inside try block, so in case of error in the promise code, instead of going to the promise's .catch() method, it goes to catch() block of the try/catch it is in.
so await makes it behave like sync code/normal code.

2. second way to create an error in a promise:
Inside a promise, if we need to create an error in the future, then we need to use different code.
For example, in this following code:

    const value = await new Promise((resolve) => {
      loadCart(() => {
        resolve();
      });
    });

the promise contains loadCart() function that loads the cart, and at the end it will run the arrow-callback function passed to it. so- this arrow function will run in the FUTURE.
'throw' does NOT work in the future! so we can't use throw syntax inside that arrow function.

Instead, Promises gives us another way to create an error:
When creating a promise, first parameter is the resolve() function. 
Second parameter is: reject() function.

reject() is a function 
- it lets us create an error in the future. 

so- Inside promise we can create errors in 2 ways:
1- use throw if we creating the error synchronously/right away 
2- use reject() if we create the error async/in the future.

Now that we learn backecnd, promises, and async await, let's use them in our project:
we make the 'Place your order button on the checkout page interactive.
When clicking the btn it will turn the cart into an order.
we will use the backend to create an order. 

Inside paymentSummary.js we added:

 document.querySelector('.js-place-order')
  .addEventListener('click', () => {
    
    fetch('https://supersimplebackend.dev/orders')
  })

In this event listener we need to make a request to the backend to create the order, 
and we need to send some data (the cart) to the backend.
So this fetch version is not suitable for that type of request.

4 types of requests:
--------------------
GET = get some information from the backend.
POST = we want the backend to create something
PUT = update something
DELETE = delete something

So far we used GET request, and that request don't let us send data to the backend.
so we will use POST, since it let us send data (body) to the backend
The fetch now will have second argument which is object that contains extra data =

method: the type of request as string. like: 'POST'
headers: headers give the backend more information about our request. 
         It is needed when we send data to the backend.
body: The actual data we want to send to the backend. In order to know how the server expect to recieve the data (structure and name of the jason sent), we need to look at the server's documentation.
In our case- look at the : https://supersimplebackend.dev/documentation 
under 'POST /orders' - we see that we need to call the passed object 'cart' 

Note: we cannot send js object of the cart, so we use JSON.stringify:

    body: JSON.stringify({
            cart: cart,
        }),

After sending this request, we need to wait for the response.
To do that, fetch returns a Promise. However, instead of using .then() at the end of fetch() 
Let's use async-await, because it's cleaner.
To use await, we must make the addEventListener('click', async ()=>{}) callback function 
async function.
Since we use await, we can save the fetch into a variable (const response) 
and remember - to get the response data, we need to use:
response.json(); 

    await response.json(); //remember it also returns a promise, so we await it
So this will give us the data that is attached to the response which should be the order 
that was created by the backend. 

Now testing-
after clicking the button, we see the cart object in the webpage console, and- 
we go to 'network' tab and search for 'supersimple' and see the 'orders' json:
click it and in the tabs we can see:
------------------------------------
Headers - of the req and response
Payload - what we sent to the server (the cart)
Preview - This is what the server sent back. an order object 
Response - The same thins as Preview- we see the order sent back from server

So this is how real world website works- Instead of creating the order in our computer, 
we send an http req to the backend to create the order.
Now, we will save the order recieved from backend.

Inside data folder we create orders.js where we will save the orders.
we created there addOrder(), exported it and used it inside paymentSummary.js:
at the bottom we called:
        addOrder(order);
To test:
in web console, after clicking the 'Place your order' button, in console we type:
  localStorage.getItem('orders')
and we see the orders we saved.
To remove the orders from localStorage we test- in console run:
  localStorage.removeItem('orders')

Next -> After we created an order, we need to go to the orders page. so-
we added:

window.location - 
-----------------
special object provided by js lets us control the URL at the top of the browser. 
if we change the location object, it will change the url at the top of webpage

window.location.href - gives us the URL at the top of the browser. and if we change this 
href property, it will change the url at the browser.
we added in code:

    window.location.href = 'orders.html';

http://127.0.0.1:5501/checkout.html => when clicking the place order btn, forwards to the 
orders page on:
http://127.0.0.1:5501/orders.html

note: 
window.location.href = 'orders.html';  <- 'orders.html' is a filepath. so it goes to the
file relative to the current checkout.html file where the current code runs.




