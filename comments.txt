Lesson 14 - Modules:
--------------
Modules = a better way to organize our code.

Currently, in the amazon.html end of body tag we put:
    <script src="./scripts/cart.js"></script>
    <script src="./data/products.js"></script>
    <script src="./scripts/amazon.js"></script>

The problem - This can cause NAMING CONFLICTS. 
for example- in cart.js we created variable
    const cart = [];

That means we cannot redeclair variable with that same name in any other of the js files, 
It will results in error on the webpage console: 
    "Uncaufght SyntaxError: Identifier 'cart' has already been declaired"

The big problem with <script></script> tags: It's hard to track naming of variables given in all 
js files and it's easy making naming conflicts.

How to solve that problem? => Using js feature names: Modules

Module = contains a variable inside a js file, so that this variable will not cause conflict with 
anything outside the file.
How to create module?
----------------------
As explained, the tag:      <script src="./scripts/cart.js"></script>
- run all the code inside 'cart.js'
- create a cart variable
- cause a naming conflict

first we remove the script tag:
    <!-- <script src="./scripts/cart.js"></script> -->

Create a Module:
================
1) Create a file 
2) Don't load the file with a script tag <script>

By doing so - 
Any variable we create inside the file, will be contained inside the file.
and it won't cause naming conflict.

So we already have the cart.js file with the definition 'const cart = [];'  in it.

Now we learn:
How To: Get a Variable Out Of a File:
-------------------------------------
1. Add type="module" attribute
2. Export
3.Import


1 - Adding type="module" attribute:
Inside the amazon.html file, we go to the last script tag and add: type="module" attribute:
    <script type="module" src="./scripts/amazon.js"></script>

type="module" attribute:
 Let's this file get variables out of other files. Enables this feature.

2 - Export:
Now, we go to the cart.js file, We want to access the variable 'const cart', 
so we add in front of the variable 'export':
    export const cart = [];    //Now this variable can be accessed outside cart.js

3 - Import:
We go to the place where we use that variable, in this case the cart variable is used 
inside amazon.js, and at the top of that file we tell the computer what variable we want to
get from another file:
    import { cart } from '../data/cart.js';     //Note: the .js extention is a must 

* Note:
1. Put all imports at the top of the file.
2. In order for modules to work: we need to use 'Live Server' to open our html files.


Benifits of Modules:
---------------------
1. Helps us avoid naming conflicts. After that change I will get naming conflict only if 
inside tha amazon.js I re-declair the 'const cart' again, but now I have much more control, 
and also: I can still declair the same variable name imported by Renaming the import:

    import {cart as myCart} from '../data/cart.js';    //renaming the import

    const cart = [];  /Now there is no conflict
2. We don't need to worry about the order of files.
with several script tags we needed the order of the script tags to be correct and it's hard to 
manage with big projects.

!Note: We still need a single <script></script> of js file because we still need to load our code.
So the file amazon.js will load the code and will import from all other files.
This file is called: The Entry-point:
        <script type="module" src="./scripts/amazon.js"></script>


 ** Another way to import: Import all the file content and rename, them I can access any func or variable:
  
  import * as cartModule from '../data/cart.js';
  cartModule.addToCart('id');
  cartModule.cart;

--------------------
12:54:44
Create the Checkout Page.

we created folder: utilsunder scripts folder

13:32 - make delete btn in the Checkout page responsive/interactive

In the checkout page: When we click the delete button:
1. The products are removed from the cart (we created removeFromCart() function in cart.js)
2. We need to update the HTML of the checkout page 


How can we remove items from the page? One way to do this:
----------------------------------------------------------
1. Use the DOM to get element to remove 
2. Use .remove() method: Every element we get from the DOM has a method: .removed() .Example:
    const button = document.querySelector('button');
    button.remove();   <==

BUT, How can we know what element on the DOM to call .remove() on?
We will add new class to the out-most div of the product element in the checkout page:
(It's the div with the class:  class="cart-item-container"), we added the 
    class="js-cart-item-container-${matchingProduct.id}" 
i.e- we concatenated the product id to the class name. Now, deleting this item by class is simple:

In the event-listener function:
    document.querySelector(`.js-cart-item-container-${productId}`).remove();


We want the state of the cart to be saved when refreshing the page and when navigating to 
different pages of the app. Therefore we =
Add the cart object to our: LocalStorage:
We added function to save cart to the localStorage in the cart.js.

**Whenever we upfdate the cart, we need to save it to localStorage, so it doesn't reset when we 
refresh the page.
===========================================================================================

Lesson 15- 
External Liberaries, MVC, Finish the Checkout Page
--------------------------------------------------
External Libraries = code that is outside of our project.

Why we use external libraries?
- let us share code
- save time
- avoid duplicating work 

How to use external libs in our code?
========================================
1) Onw way is adding the link to the lib code with <script> tag:
Example:
    - we added a script tag to the checkout.html with src="" that points to url of js file with 
    function hello() implemented:
        <script src="https://unpkg.com/supersimpledev@1.0.1/hello.js"></script>
        <script type="module" src="scripts/checkout.js"></script>
    - we called hello() from the checkout.js file 
    - now when navigating to the checkout page on the website, the console runs the function and we see 'hello' in console.


Less preferred option to load external libs: with <script> tag (since it may result in 
naming conflict)-
* we load external libs using the <script> tag.
* We add the script tag before any other script tag so that the functions in the lib will be 
available to out code.


2) Best practice for loading external libs - using Modules:
How do we use external libs and Modules togather? = 
-------------------------------------------------
We will use special version of the liberary, called:  'ESM Version'.

ESM Version = 
ESM = EcmaScript Module (EcmaScript = Javascript)
It is a version that works with Javascript Modules.

The same 'hello()' function but this time link to the ESM version: 
    https://unpkg.com/supersimpledev@1.0.1/hello.esm.js 
It's actually the same implementation but with the 'export' keyword infront of the function.
This 'export' turns the function to ESM version.
How to use this ESM version in our code? 
Instead of script tag -> At the top of the js file where we want to call the function, we just 
add the import of the module and the path is a URL:
    import { hello } from 'https://unpkg.com/supersimpledev@1.0.1/hello.esm.js';
next, just call 'hello()' in code.

**Keep in mind: Not every lib has ESM version, so for some libs we still need to use <script> tag

How do you put code on the Internet? any HTML, js, css files?
--------------------------------------------------------------
Watch video: 'How to put an HTML website online (on the Internet), on: 
    https://www.youtube.com/watch?v=p1QU3kLFPdg



===================================================================
Using external lib: 'Dayjs'
---------------------------
The following link includes the compressed code of the DayJS lib to be added in <script> tag.
Compressed code makes the code load faster to our code
MINIFICATION = The process of compressing the code (minify the code)
https://unpkg.com/dayjs@1.11.10/dayjs.min.js

This version of the code we can add to script tag.
But to add as Module:
We will instead write the folloing import at the top of the checkout.js:
    import dayjs from 'https://unpkg.com/dayjs@1.11.10/esm/index.js';
and call dayjs() in our code.
NOTE: We did not write 'import {dayjs} ...' with {}, why?

This is called:
DEFAULT EXPORT (vs NAMING EXPORT which is the regular export and import using {})= 
----------------------------------------------------------------------------------
- another way of exporting 
- we can use it when we only want to export 1 thing from a file.

Some peaple like using default exports because they feel that exporting only 1 thing from a file 
makes the code cleaner. However in my code it is my choice to use whatever I want.


Handeling the 'choose a delivary option' in the checkout page:
- The cheapset option - FREE shipping takes: 7 days to deliver
- 4.99$: takes 3 days to deliver 
- 9.99$: takes 1 day to deliver 

so How to get these dates:
1. Get today's date 
2. Do calculation (add 7 days, 3 days...)
3. display the date in easy-to-read format 
We will use popular liberary for this, called: 'DayJS'

===========================
14:20:30
'Normalizing the data' = we save the delivery-option seperately from the cart, in order to 
avoid duplicating the data-
We added under 'data' folder: 'deliveryOptions.js' file

* Removing manually data from local-storage:
If I want to remove data from local-storage of the webpage:
In the inspect->console:  
to remove specific data, like the cart(I want to test the default values in cart when it's empty):
    localStorage.removeItem('cart');
and if I want to remove ALL the data in the loval storage:
    localStorage.clear();

14:43:30

MVC - Design Pattern that lets us orgenize our code:
===================================================
Inside checkout.js:
We put all the code that generates the web page into function: renderOrderSummary(),
and whenever the delivery-options updated, this function calls itself (recursion). Why?

This delivery option will make changes to several elements in the page:
i.e- to the Delivery date title, and to the Order Summary where the cost is updated.
This is why we better re-run the whole function that renders the page as whole:
      renderOrderSummary(); //RECURSION

Instead of using the DOM and change the elements directly, we re-run the code to
build the page again whenever it is updated.
renderOrderSummary();

This technique where we:
1. Update the data 
2. Regenerates all the HTML 
is called = MVC = Model-View-Controller

In MVC, We split our code into 3 parts:
1. Model = All the code that saves and manages the data (in our project its: 'cart.js')
2. View = This is code that Takes the data and displays it on the page (in 'checkout.js'-> renderOrderSummary()) 
3. Controller = runs some code when we interact with the page (The event-listeners)

These 3 parts interact with eachother in a loop: 

Model ---> View ---> Controller --
 |_______________________________|

first, we use Model to generate the view (we took the model/data which is our cart, and 
in chckout.js we generated the View) 
Then, when we interact with the view, it runs the Controller 
Then, the Controller will update the Model (The EventListeners render the webpage)
And finally, we use the updated Model to generate the view (renderOrderSummary())

We use MVC because = This way it makes sure the page always matches the data


Lesson 16 - TESTING:
======================
1. Manual Testing = When we manualy open our website and try our code. 
Disadvantages: 
- Hard to test every situation 
- Hard to re-test the code 

Best practice:
2. Automated Testing = Using code to test code 

We created upper-level folder: 'tests'. It will containg js files corresponding to each 
code we want to test.

REMEMBER: 
We can't run javascript files directly. We need to load js files from html file.
so we create html file for the js test files to be loaded there to the web (run the tests.html 
with Live-server).

Inside tests/tests.html we added the script tag to load the js test file.
Note: we need to add type="module" because we want to use the ESM feature:
    <script type="module" src="monyTest.js"></script>

How many test cases should we have?
1. Basic test cases = tests if the code is working 
2. Edge cases = test with values that are tricky 

Inside the tsets.js:
Naming conventions for the tests titles: To describe what the code is doing.
We should group related tests:
'test suite' = group of related tests

15:58:40-
Testing Framework:
================== 
It's external library that helps us write tests easier. 
We will use a popular testing framework called: 'Jasmine' 

Jasmine 
--------
Link for download: https://github.com/jasmine/jasmine/releases/tag/v5.1.1 
Docs: https://jasmine.github.io/api/5.1/global 

we downloaded the zip file: 'jasmine-standalone-5.1.1', extracted the folder and added it to our project. We renamed the folder to: 'tests-jasmine' in order 
to make it clear this folder contains tests created by jasmine.

So- this is another way to load external library to our project- By downloading 
the code and putting it in our project. It's usefull when external lib has 
many different files, like this lib.











