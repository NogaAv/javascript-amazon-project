Lesson 14 - Modules:
--------------
Modules = a better way to organize our code.

Currently, in the amazon.html end of body tag we put:
    <script src="./scripts/cart.js"></script>
    <script src="./data/products.js"></script>
    <script src="./scripts/amazon.js"></script>

The problem - This can cause NAMING CONFLICTS. 
for example- in cart.js we created variable
    const cart = [];

That means we cannot redeclair variable with that same name in any other of the js files, 
It will results in error on the webpage console: 
    "Uncaufght SyntaxError: Identifier 'cart' has already been declaired"

The big problem with <script></script> tags: It's hard to track naming of variables given in all 
js files and it's easy making naming conflicts.

How to solve that problem? => Using js feature names: Modules

Module = contains a variable inside a js file, so that this variable will not cause conflict with 
anything outside the file.
How to create module?
----------------------
As explained, the tag:      <script src="./scripts/cart.js"></script>
- run all the code inside 'cart.js'
- create a cart variable
- cause a naming conflict

first we remove the script tag:
    <!-- <script src="./scripts/cart.js"></script> -->

Create a Module:
================
1) Create a file 
2) Don't load the file with a script tag <script>

By doing so - 
Any variable we create inside the file, will be contained inside the file.
and it won't cause naming conflict.

So we already have the cart.js file with the definition 'const cart = [];'  in it.

Now we learn:
How To: Get a Variable Out Of a File:
-------------------------------------
1. Add type="module" attribute
2. Export
3.Import


1 - Adding type="module" attribute:
Inside the amazon.html file, we go to the last script tag and add: type="module" attribute:
    <script type="module" src="./scripts/amazon.js"></script>

type="module" attribute:
 Let's this file get variables out of other files. Enables this feature.

2 - Export:
Now, we go to the cart.js file, We want to access the variable 'const cart', 
so we add in front of the variable 'export':
    export const cart = [];    //Now this variable can be accessed outside cart.js

3 - Import:
We go to the place where we use that variable, in this case the cart variable is used 
inside amazon.js, and at the top of that file we tell the computer what variable we want to
get from another file:
    import { cart } from '../data/cart.js';     //Note: the .js extention is a must 

* Note:
1. Put all imports at the top of the file.
2. In order for modules to work: we need to use 'Live Server' to open our html files.


Benifits of Modules:
---------------------
1. Helps us avoid naming conflicts. After that change I will get naming conflict only if 
inside tha amazon.js I re-declair the 'const cart' again, but now I have much more control, 
and also: I can still declair the same variable name imported by Renaming the import:

    import {cart as myCart} from '../data/cart.js';    //renaming the import

    const cart = [];  /Now there is no conflict
2. We don't need to worry about the order of files.
with several script tags we needed the order of the script tags to be correct and it's hard to 
manage with big projects.

!Note: We still need a single <script></script> of js file because we still need to load our code.
So the file amazon.js will load the code and will import from all other files.
This file is called: The Entry-point:
        <script type="module" src="./scripts/amazon.js"></script>


 ** Another way to import: Import all the file content and rename, them I can access any func or variable:
  
  import * as cartModule from '../data/cart.js';
  cartModule.addToCart('id');
  cartModule.cart;

--------------------
12:54:44
Create the Checkout Page.

we created folder: utilsunder scripts folder

13:32 - make delete btn in the Checkout page responsive/interactive

In the checkout page: When we click the delete button:
1. The products are removed from the cart (we created removeFromCart() function in cart.js)
2. We need to update the HTML of the checkout page 


How can we remove items from the page? One way to do this:
----------------------------------------------------------
1. Use the DOM to get element to remove 
2. Use .remove() method: Every element we get from the DOM has a method: .removed() .Example:
    const button = document.querySelector('button');
    button.remove();   <==

BUT, How can we know what element on the DOM to call .remove() on?
We will add new class to the out-most div of the product element in the checkout page:
(It's the div with the class:  class="cart-item-container"), we added the 
    class="js-cart-item-container-${matchingProduct.id}" 
i.e- we concatenated the product id to the class name. Now, deleting this item by class is simple:

In the event-listener function:
    document.querySelector(`.js-cart-item-container-${productId}`).remove();


We want the state of the cart to be saved when refreshing the page and when navigating to 
different pages of the app. Therefore we =
Add the cart object to our: LocalStorage:
We added function to save cart to the localStorage in the cart.js.

**Whenever we upfdate the cart, we need to save it to localStorage, so it doesn't reset when we 
refresh the page.
===========================================================================================

Lesson 15- 
External Liberaries, MVC, Finish the Checkout Page
--------------------------------------------------
External Libraries = code that is outside of our project.

Why we use external libraries?
- let us share code
- save time
- avoid duplicating work 

How to use external libs in our code?
========================================
1) Onw way is adding the link to the lib code with <script> tag:
Example:
    - we added a script tag to the checkout.html with src="" that points to url of js file with 
    function hello() implemented:
        <script src="https://unpkg.com/supersimpledev@1.0.1/hello.js"></script>
        <script type="module" src="scripts/checkout.js"></script>
    - we called hello() from the checkout.js file 
    - now when navigating to the checkout page on the website, the console runs the function and we see 'hello' in console.


Less preferred option to load external libs: with <script> tag (since it may result in 
naming conflict)-
* we load external libs using the <script> tag.
* We add the script tag before any other script tag so that the functions in the lib will be 
available to out code.


2) Best practice for loading external libs - using Modules:
How do we use external libs and Modules togather? = 
-------------------------------------------------
We will use special version of the liberary, called:  'ESM Version'.

ESM Version = 
ESM = EcmaScript Module (EcmaScript = Javascript)
It is a version that works with Javascript Modules.

The same 'hello()' function but this time link to the ESM version: 
    https://unpkg.com/supersimpledev@1.0.1/hello.esm.js 
It's actually the same implementation but with the 'export' keyword infront of the function.
This 'export' turns the function to ESM version.
How to use this ESM version in our code? 
Instead of script tag -> At the top of the js file where we want to call the function, we just 
add the import of the module and the path is a URL:
    import { hello } from 'https://unpkg.com/supersimpledev@1.0.1/hello.esm.js';
next, just call 'hello()' in code.

**Keep in mind: Not every lib has ESM version, so for some libs we still need to use <script> tag

How do you put code on the Internet? any HTML, js, css files?
--------------------------------------------------------------
Watch video: 'How to put an HTML website online (on the Internet), on: 
    https://www.youtube.com/watch?v=p1QU3kLFPdg



===================================================================
Using external lib: 'Dayjs'
---------------------------
The following link includes the compressed code of the DayJS lib to be added in <script> tag.
Compressed code makes the code load faster to our code
MINIFICATION = The process of compressing the code (minify the code)
https://unpkg.com/dayjs@1.11.10/dayjs.min.js

This version of the code we can add to script tag.
But to add as Module:
We will instead write the folloing import at the top of the checkout.js:
    import dayjs from 'https://unpkg.com/dayjs@1.11.10/esm/index.js';
and call dayjs() in our code.
NOTE: We did not write 'import {dayjs} ...' with {}, why?

This is called:
DEFAULT EXPORT (vs NAMING EXPORT which is the regular export and import using {})= 
----------------------------------------------------------------------------------
- another way of exporting 
- we can use it when we only want to export 1 thing from a file.

Some peaple like using default exports because they feel that exporting only 1 thing from a file 
makes the code cleaner. However in my code it is my choice to use whatever I want.


Handeling the 'choose a delivary option' in the checkout page:
- The cheapset option - FREE shipping takes: 7 days to deliver
- 4.99$: takes 3 days to deliver 
- 9.99$: takes 1 day to deliver 

so How to get these dates:
1. Get today's date 
2. Do calculation (add 7 days, 3 days...)
3. display the date in easy-to-read format 
We will use popular liberary for this, called: 'DayJS'

===========================
14:20:30
'Normalizing the data' = we save the delivery-option seperately from the cart, in order to 
avoid duplicating the data-
We added under 'data' folder: 'deliveryOptions.js' file

* Removing manually data from local-storage:
If I want to remove data from local-storage of the webpage:
In the inspect->console:  
to remove specific data, like the cart(I want to test the default values in cart when it's empty):
    localStorage.removeItem('cart');
and if I want to remove ALL the data in the loval storage:
    localStorage.clear();

14:43:30

MVC - Design Pattern that lets us orgenize our code:
===================================================
Inside checkout.js:
We put all the code that generates the web page into function: renderOrderSummary(),
and whenever the delivery-options updated, this function calls itself (recursion). Why?

This delivery option will make changes to several elements in the page:
i.e- to the Delivery date title, and to the Order Summary where the cost is updated.
This is why we better re-run the whole function that renders the page as whole:
      renderOrderSummary(); //RECURSION

Instead of using the DOM and change the elements directly, we re-run the code to
build the page again whenever it is updated.
renderOrderSummary();

This technique where we:
1. Update the data 
2. Regenerates all the HTML 
is called = MVC = Model-View-Controller

In MVC, We split our code into 3 parts:
1. Model = All the code that saves and manages the data (in our project its: 'cart.js')
2. View = This is code that Takes the data and displays it on the page (in 'checkout.js'-> renderOrderSummary()) 
3. Controller = runs some code when we interact with the page (The event-listeners)

These 3 parts interact with eachother in a loop: 

Model ---> View ---> Controller --
 |_______________________________|

first, we use Model to generate the view (we took the model/data which is our cart, and 
in chckout.js we generated the View) 
Then, when we interact with the view, it runs the Controller 
Then, the Controller will update the Model (The EventListeners render the webpage)
And finally, we use the updated Model to generate the view (renderOrderSummary())

We use MVC because = This way it makes sure the page always matches the data


Lesson 16 - TESTING:
======================
1. Manual Testing = When we manualy open our website and try our code. 
Disadvantages: 
- Hard to test every situation 
- Hard to re-test the code 

Best practice:
2. Automated Testing = Using code to test code 

We created upper-level folder: 'tests'. It will containg js files corresponding to each 
code we want to test.

REMEMBER: 
We can't run javascript files directly. We need to load js files from html file.
so we create html file for the js test files to be loaded there to the web (run the tests.html 
with Live-server).

Inside tests/tests.html we added the script tag to load the js test file.
Note: we need to add type="module" because we want to use the ESM feature:
    <script type="module" src="monyTest.js"></script>

How many test cases should we have?
1. Basic test cases = tests if the code is working 
2. Edge cases = test with values that are tricky 

Inside the tsets.js:
Naming conventions for the tests titles: To describe what the code is doing.
We should group related tests:
'test suite' = group of related tests

15:58:40-
Testing Framework:
================== 
It's external library that helps us write tests easier. 
We will use a popular testing framework called: 'Jasmine' 

Jasmine 
--------
Link for download: https://github.com/jasmine/jasmine/releases/tag/v5.1.1 
Docs: https://jasmine.github.io/api/5.1/global 

we downloaded the zip file: 'jasmine-standalone-5.1.1', extracted the folder and added it to our project. We renamed the folder to: 'tests-jasmine' in order 
to make it clear this folder contains tests created by jasmine.

So- this is another way to load external library to our project- By downloading 
the code and putting it in our project. It's usefull when external lib has 
many different files, like this lib.

Inside jasmine folder:
'SpecRunner.html' - is the file that loads all the tests (so it does the same thing as our 
tests/tests.html we created before).
in jasmine: 'spec'='test'
We renamed this file to tests.html and when we open this file with Live-server, we see 
a nice website that presents the testings.
so jasmin:
- create test suite 
- create tests (spec filder is the test folder) 
- compare values and display result 

From tests.html we delete the default example scripts tags:
  <!-- include source files here... -->
  <script src="src/Player.js"></script>
  <script src="src/Song.js"></script>

  <!-- include spec files here... -->
  <script src="spec/SpecHelper.js"></script>
  <script src="spec/PlayerSpec.js"></script>

we also delete the src folder and the spec folder(contains example code).
So, aventually we have inside test-jasmin folder: 
the lib folder, tests.html (and license file).

Under the main 'test-jasmine' folder we create our files for testing and we should keep 
the folder structure similar to the project tested, so for example:
The mony.js file is located under Utils folder. so- in our jasmine folder we create monyTest.js 
under Util folder as well. to match the structure of folders and files.

Instructor's mistake:
** Instructure note:  In our project- There is mistake in the structure of the project:
The data folder (that contains js files) should be under the 'script' folder and not outside it.
For this reason now the jasmin folder inner structure doesn't match exactly the project structure, but it should (i.e- the data and Util folders should be at the same level in the project, just as it is in the testing jasmin folder). So the structure in jasmin we made is the correct one.

'Flaky Test' = test that sometimes passes and sometimes fails.

'Mocks' = a feature of jasmine, lets us replace a method with a fake version.
spyOn() - function in jasmine that lets us create Mock 
    !!NOTE: A mock only latst for 1 test (so for every test I need to use spyOn() if I want to mock)
spyOn() has special feature - It records every time a method is used, and so we can after check parameters:

//toHaveBeenCalledTimes() - checks how many time localStorage.setItem() was called in the code above. 
//Note: This only works if the method was mocked by spyOn()
    expect(localStorage.setItem).toHaveBeenCalledTimes(1);

Also- we can check the values that the mocked calles returned (on docs)

**After we run the testing jasmine and see on jasmine webpage that all tests pass, we CLEAN the localstorage on 
the webpage - 
We will remove everything from localStorage, because we want to make sure we start clean.
NOTE: The jasmine webpage has the same localStorage of our project!-localStorage belongs to a DOMAIN, 
in our case the domain is: http://127.0.0.1:5501 
and since both our project and jasmin run by the LiveServer - they have the same localStorage, so after the testing 
we better clear the storage to not mess anything up:
    On the jasmine webpage we right-click->Inspect->Console->  and run the command: 
        localStorage.clear()


16:51:30-
Up until now we made:
'Unit Tests' = testing 1 piece of the code.

But what if we want to test a whole page, or part of the page? This is more complicated test, 
called:
'Integration Test' = tests many units/pieces of code working together.

like: renderOrderSummary() function inside orderSummary.js file. This function runs many other functions and pieces of code.

renderOrderSummary() creates part of the checkout page. 
When we test a page or part of page, we have 2 things to test:
1. How the page looks
2. How the page behaves

How do we test how the page looks?
-----------------------------------
the page html order summary section is created and loaded in orderSummary.js, with line:

      document.querySelector('.js-order-summary').innerHTML = cartSummaryHTML;
so- inside the 'tests.html' file, we will add <div><div> inside body, and this div 
will serve as a container, imitating the div with the class="js-order-summary" in the project's 
code. 
we use container inside the <body> and not insert to the body itself because it may contain 
the results of jasmine to be displayed in the jasmine webpage.

so we added :
        <div class="js-test-container"></div>
and now we can query and use that container in our testing code.


17:27:10-

HOOKS:
======
Hook - Lets us run some code for each test.
'beforeEach' hook = It's a setup code we can run before running test.

Hooks in Jasmine:
=================
beforeEach() = runs code before EACH test
afterEach() = runs code after EACH test (gppd gor cleanup code)
beforeAll() = runs code before ALL tests
afterAll() = runs code after ALL tests

Process when we run code:
--------------------------
1. Make changes to code 
2. Re-run the tests 
3. Save changes to Git

we renamed 'tests-jasmine' to 'tests'


Lesson 17 - 
OOP = Object Oriented Programming:
===================================
Organizing our code into objects. 

So far- we used in our code- 
Procedural Programming = a set of step-by-step instructions(=functions) - (in cart.js- cart object declaired up in file and the rest of file has seperated functions for the cart)

we created OOP version to the cart.js => 'cart-oop.js'
According to OOP = We grouped our data and functions togather into an object.
* Now, How we test this code? 
At the top of 'checkout.js' we added:
    import '../data/cart-oop.js'; 
This is another syntax to import code. This will run all the code in that file without importing anything, which is what we want for testing it. Now we open 'checkout.html' which runs 'checkout.js' and we open the console to see what we consoled in the cart-oop.js file.


Why do we use OOP?
* OOP - tries to represent the real world. Makes the code intuitive and easy to understand 
* Easy to create multiple objects. 
For example: 
The real Amazon.com has a feature called: 'Amazon Business' where you can have seperate cart for your business.

So- How do we create 2 separate carts in our current code?
With OOP - this is easy: 
1) we can just make a copy of the cart-oop object we created: 
We go to 'cart-oop.js' , copy the cart object code, paste it under the first cart object, 
change the object's name - we changed it to: businessCart, change the name of cart in the localStorage to diffrentiate between carts, and that's it! (in- 'cart-oop-no-class.js')

BUT - This way we're copy-pasting a lot of code. It makes our code messy and hard to manage.
We will resolve that by:
2) Using a function to generate multiple objects:  'cart-oop-function.js'

3) Better way for generating objects:
CLASS:
class = Object generator
Classes are cleaner and has more features than a function.

With classes, each object of a class is called: Instance of a class:
    const cart = new Cart();   //cart is instance of Cart class 

We can also check if an object is an Instance of a class:
    console.log(cart instanceof Cart);  //true

Benifits of classes:
--------------------
- A class looks like the object that it generates, and it is cleaner than using function to 
generate object.
- Classes have extra features for Object-Oriented Programming:
    - Constructor = Lets us put setup code inside the class. 
    * It is a unique function that is called automatically when an object is created.
    * It has to be named "constructor".
    * It should not return anything.

Special features of class:
Private properties and methods:
--------------------------------
Some properties and methods should not be available outside the class. 
for example- this is a problem if outside the class a user does this and changes localStorage:
    cart.localStorageKey = 'aaa'; 
so we add '#' infront of the property name, and make it 'private property' as opposed to 
'public property'.

field = property

methods can also be private. for example: loadFromStorage() should not be called from outside the class. so we add #:
Now - We will Use classes in our project:
we will need to replace every place we use cart in our project with the class cart.
However - The istructor left this as challange exercise for me.


18:29:50-
We will now - Keep working on Home-Page:

inside products.js we have array ob objects, each object represents an object.
We will learn a technique = 
Converting an object into a class:
-----------------------------------
We will use a class to generate these objects.

in products.js-
Technique demonstrated by Instructor:
"Converting an object into a class":
------------------------------------
We sent the class constructor an object as whole, and the class converts it to class.
We actually send an object and wrap that object with a class.
The reason we do this =
Classes has more features then object, like: we can add methods, private properties and methods.

With this technique we get the same object as before, but enhanced version. (It has some extra features)

Now, after converting the regular objects to class-objects, We added to product 
class Methods:  getStarsUrl() and getPrice() 
and then- we went back to 'amazon.js' and 'orderSummary.js' and used there these methods inside 
html ctring construction. This makes the code cleaner.

Lastely - we open test.html with LiveServer to make sure the code still works and that all the 
tests pass


18:52:20 = 
Lesson:  INHERITANCE:
======================
Inheritance - lets us reuse code between classes.

In the Home page, we have different TYPES of products:
                         ----------------
For example- T-shirt and Toaster:
T-shirt is 'clothing' product, and Toaster is 'appliances' product
Both are products: They have name, price and rating, 
But They are a MORE SPECIFIC type of product. 

clothing has the regular properties of product, but it can also have specific properties, like:
a size-chart. So, a class for such product would look like this:

    class Clothing{
        id;
        image;
        name;
        rating;
        priceCents;

        sizeChartLink;    //<- specific for clothing.
    }

BUT, If I add this class as is in addition to the Product class we have, we will be 
duplicating code, since both classes has common properties (the base product properties) = 
These is why we have the OOP feature: Inheritance 
Inheritance = allows class to get properties and methods from another class, so we don't need 
to copy redundant code. 
So instead the class described up here, we will use inheritance:

   class Clothing extends Product{
        //Get all properties of Product

        sizeChartLink;

        constructor(productDetails){
        //Get the constructor of Product

          this.sizeChartLink = productDetails.sizeChartLink;
        }
    }

Inside products.js we added inheriting child class: class Clothing

*We use inheritance when we have:
One class is a MORE SPECIFIC TYPE of another class.
Inheritance = Lets us reuse code between classes.

super(); - calls the contructor of the parent class.

*NOTE: If we don't create a constructor, by default it will run the parent constructor:
so-

class Clothing extends Product{                       class Clothing extends Product{
                                --By Default is:-->     constructor(param1){
}                                                          super(param1);
                                                           }
                                                      }


So now, we have Product class and Clothing class. 
How do we know what product in the products array we should convert to Product class and which 
to convert to Clothing class?
---------------------------- 
Discriminator Property = property that tells us to which class we should convert it to.

In our products array, some have the property:
    type: 'clothing',
this will serve as the discriminator property.
now, in the .map() we check if this property exists in the current object and accordingly 
call the Clothing() constructor.

Next - we Display the size chart link on the page:
On home page, wherevert there is a clothing product - we will display size-chart 
undernith.
We do that using inheritance => we added to the child Clothing class a method: 
extraInfoHTML() 
And since we call that method to EVERY object in the products array when we create 
the amazon home-page, we also need to add that method in the parent class, only there 
it returns '' empty string:
In amazon.js:

// for product of type Product it returns '', for product of type Clothing it 
// returns link
    ${product.extraInfoHTML()}
    <div class="product-spacer"></div>

NOTE - Don't get confused:
The following iterating code inside 'amazon.js':
    products.forEach((product, index) => {..} 
Iterates through the objects in a way that 'product' may be a reference to Clothing 
object or a reference to Product object. SO- when calling the method:
    product.extraInfoHTML()
The correct method is induced according to the type of object. 

This is called:
 POLYMORPHISM = use a method without knowing the class.

OVERRIDING:
--------------
extraInfoHTML() - In child class it Overrides the parent method.
Method Overriding: method override/replace the parent's method 

If we really want to access the parent class from the child class, we use super 
inside the child object:
    super.extraInfoHTML()

**Testing classes = Is the same as normal tests.

Built-in Classes:
----------------
new Date() = generates an object that represents the current date.

We used earlier - DayJS library:
DayJS uses this Date class behind the scenes.
DayJS gives us a lot of extra features.
- so we use DayJS instead of Date directly.

'this' keywoed in JavaScript:
-----------------------------
* As we said - "this" lets an object access its own properties.
In JS - "this" can actually be used ANYWHERE in our code, but if it's outside an object, we get:
'undefined'
Originally in javascript, "this"=window object
However, this behaviour caused alot of confusion, therefore:
when they released Javascript modules, inside a module, "this"=undefined.

* We cannot use 'this' inside regular object like this:

    const object2 = {
    a: 2,
    b: this.a, //invalid code - 'this' is not yet defined here
    };

* Use "this" inside function:
    function logThis() {
      console.log(this);
    }
    logThis(); //undefined
again, we are NOT inside an object, so there's nothing for "this" to point to.
BUT - "this" has special feature - and inside a function we can change "this" to whatever we want

logThis.call() //logThis.call() runs the function just the same as logThis(), only we can 
set the value of "this" to whatever we want. So-

logThis.call('hello'); //hello

So- logThis.call() enables passing to function value for "this" as first parameter.

   function logThis(param1, param2) {
      console.log(this);
    }

  logThis("hello"); //undefined
  logThis.call("hello", "world"); //hello

* Arrow functions do NOT change the value of "this"
"this" inside an arrow-function- keeps the value that it has outside the arrow-function.

WHY are Arrow functions designed this way?  (-i.e- to keep 'this' with the value it has outside the arrow-function?):
--------------------
JS had a common problem in the past:
see code:

const object3 = {
    method(){
        console.log(this); //When we are inside the method, 'this' points to the object

        [1, 2, 3].foreach(function() {
         console.log(this); //But here, inside the callback, it points to undefined
        })    
    }
};

When we are inside the method, 'this' points to the object. 
But when we are trying to do the foreach loop, there, the 'this' doesn't point to the object anymore, it points to undefined, because this 'this' is inside regular function, which 
has no access to the 'this' of the object.
Remember - In a regular function - 'this' is undefined.
SO - To solve this, We have the Arrow-function.
With Arrow function, the 'this' is equale to whatever it's value before the arrow function call.
Arrow functions do not change the value of "this". 

const object3 = {
    method(){
        console.log(this); //When we are inside the method, 'this' points to the object

        [1, 2, 3].foreach(function => {
         console.log(this); //Here, inside the arrow-function, 'this' still points to object
        })    
    }
};

so- Arrow functions were designed to avoid accidently overriding "this".

To summarize the "this":
1. Inside a method, "this" points to the outer object.
2. Inside a function, this=undefined, But we can change that with functionName()call(param);
3. Arrow functions do not change the value of "this".
















